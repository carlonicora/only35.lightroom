{"id":"only35.lightroom-utt","title":"Only35 Lightroom Plugin","description":"## Overview\n\nImplement a Lightroom Classic Publish Service plugin that enables photographers to publish photos directly to Only35.\n\n## Problem Statement\n\nPhotographers must currently:\n1. Export from Lightroom to disk\n2. Upload manually via web interface\n3. Lose metadata continuity\n\n## Solution\n\nImplement `only35.lrplugin` with:\n- OAuth 2.0 authentication (manual code entry fallback)\n- Publish Service for collection-based uploads\n- Metadata sync (stars, keywords, flags)\n- Pre-signed S3 uploads via Only35 API\n\n## Spec Path\n\nopenspec/changes/lightroom-plugin/\n\n## Architecture\n\n```\nonly35.lrplugin/\n├── Info.lua                        # Plugin manifest\n├── Only35PublishServiceProvider.lua # Publish service callbacks\n├── Only35API.lua                   # HTTP client, API calls\n├── Only35Auth.lua                  # OAuth flow, token management\n└── Only35Utils.lua                 # Logging, constants, helpers\n```\n\n## Tasks\n\nPhase 1: Foundation\n- 1.1 Plugin Manifest (Info.lua)\n- 1.2 Utilities Module (Only35Utils.lua)\n\nPhase 2: Authentication\n- 2.1 OAuth Module (Only35Auth.lua)\n\nPhase 3: API Client\n- 3.1 HTTP Client (Only35API.lua)\n\nPhase 4: Publish Service\n- 4.1 Service Provider (Only35PublishServiceProvider.lua)\n- 4.2 UI Sections (integrated in 4.1)\n- 4.3 Metadata Mapping (integrated in 4.1)\n- 4.4 Export Settings (integrated in 4.1)\n\nPhase 5: Error Handling \u0026 Polish\n- 5.1 Error Handling (across modules)\n- 5.2 Distribution (package structure)\n\n## Exit Criteria\n\n```bash\n# Plugin structure exists\nls -la only35.lrplugin/\n\n# All required files present\ntest -f only35.lrplugin/Info.lua\ntest -f only35.lrplugin/Only35Utils.lua\ntest -f only35.lrplugin/Only35Auth.lua\ntest -f only35.lrplugin/Only35API.lua\ntest -f only35.lrplugin/Only35PublishServiceProvider.lua\n\n# Lua syntax valid\nluac -p only35.lrplugin/*.lua || lua -e \"for f in io.popen('ls only35.lrplugin/*.lua'):lines() do local ok, err = loadfile(f); if not ok then print(err); os.exit(1) end end\"\n```","status":"closed","priority":1,"issue_type":"epic","owner":"carlo.nicora@gmail.com","created_at":"2026-01-20T08:52:11.886954+01:00","created_by":"Carlo Nicora","updated_at":"2026-01-20T09:09:59.682422+01:00","closed_at":"2026-01-20T09:09:59.682422+01:00","close_reason":"Done: All 7 tasks complete - Only35 Lightroom Plugin fully implemented with OAuth, API client, Publish Service, error handling, and distribution package","labels":["openspec:lightroom-plugin"]}
{"id":"only35.lightroom-utt.1","title":"Create Plugin Manifest (Info.lua)","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/lightroom-plugin/\n**Task**: 1.1 Plugin Manifest from tasks.md\n\n## Requirements\n\nCreate the plugin manifest file that registers the Only35 plugin with Lightroom Classic.\n\n**Manifest Requirements:**\n- LrSdkVersion = 13.0 (target Lightroom Classic 13+)\n- LrSdkMinimumVersion = 10.0 (support back to Lightroom Classic 10)\n- LrToolkitIdentifier = 'com.only35.lightroom' (unique plugin ID)\n- Register LrExportServiceProvider pointing to Only35PublishServiceProvider.lua\n- Include VERSION table for version tracking\n- Set LrPluginName = \"Only35\"\n\n## Reference Implementation\n\nCREATE DIRECTORY: `only35.lrplugin/`\n\nCREATE FILE: `only35.lrplugin/Info.lua`\n\n```lua\n--[[----------------------------------------------------------------------------\n    Only35 Lightroom Plugin\n    \n    Publish Service plugin for uploading photos to Only35.\n    Supports OAuth 2.0 authentication and metadata sync.\n------------------------------------------------------------------------------]]\n\nreturn {\n    -- SDK version requirements\n    LrSdkVersion = 13.0,\n    LrSdkMinimumVersion = 10.0,\n    \n    -- Plugin identification\n    LrToolkitIdentifier = \"com.only35.lightroom\",\n    LrPluginName = \"Only35\",\n    \n    -- Export/Publish Service registration\n    LrExportServiceProvider = {\n        title = \"Only35\",\n        file = \"Only35PublishServiceProvider.lua\",\n    },\n    \n    -- Plugin info provider for About dialog\n    LrPluginInfoProvider = \"Only35InfoProvider.lua\",\n    \n    -- Version information\n    VERSION = { \n        major = 1, \n        minor = 0, \n        revision = 0, \n        build = 1,\n        display = \"1.0.0\",\n    },\n}\n```\n\nCREATE FILE: `only35.lrplugin/Only35InfoProvider.lua`\n\n```lua\n--[[----------------------------------------------------------------------------\n    Only35 Plugin Info Provider\n    \n    Provides plugin information for Lightroom's Plugin Manager.\n------------------------------------------------------------------------------]]\n\nreturn {\n    sectionsForBottomOfDialog = function(viewFactory, propertyTable)\n        local LrHttp = import 'LrHttp'\n        \n        return {\n            {\n                title = \"About Only35\",\n                \n                viewFactory:row {\n                    viewFactory:static_text {\n                        title = \"Only35 Lightroom Plugin v1.0.0\",\n                        font = \"\u003csystem/bold\u003e\",\n                    },\n                },\n                \n                viewFactory:row {\n                    viewFactory:static_text {\n                        title = \"Publish your photos directly to Only35.\",\n                    },\n                },\n                \n                viewFactory:row {\n                    viewFactory:push_button {\n                        title = \"Visit Only35\",\n                        action = function()\n                            LrHttp.openUrlInBrowser(\"https://only35.com\")\n                        end,\n                    },\n                    viewFactory:push_button {\n                        title = \"Get Help\",\n                        action = function()\n                            LrHttp.openUrlInBrowser(\"https://only35.com/help/lightroom\")\n                        end,\n                    },\n                },\n            },\n        }\n    end,\n}\n```\n\n## Exit Criteria\n\n```bash\n# Directory exists\ntest -d only35.lrplugin \u0026\u0026 echo \"PASS: Plugin directory exists\" || echo \"FAIL: Plugin directory missing\"\n\n# Info.lua exists and has correct content\ntest -f only35.lrplugin/Info.lua \u0026\u0026 echo \"PASS: Info.lua exists\" || echo \"FAIL: Info.lua missing\"\n\n# Check for required fields\ngrep -q \"LrSdkVersion = 13.0\" only35.lrplugin/Info.lua \u0026\u0026 echo \"PASS: LrSdkVersion correct\" || echo \"FAIL: LrSdkVersion wrong\"\ngrep -q \"LrSdkMinimumVersion = 10.0\" only35.lrplugin/Info.lua \u0026\u0026 echo \"PASS: LrSdkMinimumVersion correct\" || echo \"FAIL: LrSdkMinimumVersion wrong\"\ngrep -q 'LrToolkitIdentifier = \"com.only35.lightroom\"' only35.lrplugin/Info.lua \u0026\u0026 echo \"PASS: LrToolkitIdentifier correct\" || echo \"FAIL: LrToolkitIdentifier wrong\"\ngrep -q \"LrExportServiceProvider\" only35.lrplugin/Info.lua \u0026\u0026 echo \"PASS: LrExportServiceProvider registered\" || echo \"FAIL: LrExportServiceProvider missing\"\n\n# Lua syntax check\nlua -e \"local ok, err = loadfile('only35.lrplugin/Info.lua'); if not ok then print('FAIL: ' .. err); os.exit(1) else print('PASS: Lua syntax valid') end\" 2\u003e/dev/null || echo \"PASS: Lua syntax valid (lua not installed, manual check needed)\"\n```\n\n### Verification Checklist\n- [ ] only35.lrplugin/ directory created\n- [ ] Info.lua contains LrSdkVersion = 13.0\n- [ ] Info.lua contains LrSdkMinimumVersion = 10.0\n- [ ] Info.lua contains LrToolkitIdentifier = \"com.only35.lightroom\"\n- [ ] Info.lua registers LrExportServiceProvider pointing to Only35PublishServiceProvider.lua\n- [ ] Info.lua includes VERSION table\n- [ ] Only35InfoProvider.lua created with plugin info sections\n- [ ] Lua syntax is valid (no parse errors)\n\n## Files to Modify\n\n- `only35.lrplugin/` (CREATE directory) - Plugin root folder\n- `only35.lrplugin/Info.lua` (CREATE) - Plugin manifest\n- `only35.lrplugin/Only35InfoProvider.lua` (CREATE) - Plugin info provider","status":"closed","priority":0,"issue_type":"task","owner":"carlo.nicora@gmail.com","created_at":"2026-01-20T08:52:41.184112+01:00","created_by":"Carlo Nicora","updated_at":"2026-01-20T09:03:35.733083+01:00","closed_at":"2026-01-20T09:03:35.733083+01:00","close_reason":"Done: Created Info.lua and Only35InfoProvider.lua with all required manifest fields","labels":["openspec:lightroom-plugin"],"dependencies":[{"issue_id":"only35.lightroom-utt.1","depends_on_id":"only35.lightroom-utt","type":"parent-child","created_at":"2026-01-20T08:52:41.184861+01:00","created_by":"Carlo Nicora"}]}
{"id":"only35.lightroom-utt.2","title":"Create Utilities Module (Only35Utils.lua)","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/lightroom-plugin/\n**Task**: 1.2 Utilities Module from tasks.md\n\n## Requirements\n\nCreate the utilities module containing all constants and helper functions used across the plugin.\n\n**Constants Required:**\n- API_BASE_URL = \"https://api.only35.com\"\n- WEB_BASE_URL = \"https://only35.com\"\n- CLIENT_ID = \"lightroom\"\n- REDIRECT_URI = \"https://only35.com/oauth/success\"\n- SCOPES = {\"photos:read\", \"photos:write\", \"rolls:read\", \"rolls:write\"}\n\n**Endpoints Map:**\n- AUTHORIZE = \"/oauth/authorize\"\n- TOKEN = \"/oauth/token\"\n- REVOKE = \"/oauth/revoke\"\n- UPLOAD_URL = \"/photographs/upload-url\"\n- PHOTOGRAPHS = \"/photographs\"\n- ROLLS = \"/rolls\"\n\n**Helper Functions:**\n- generateRandomString(length) - Generate random alphanumeric string for CSRF state\n- log(message) - Debug logging (optional, for development)\n\n## Reference Implementation\n\nCREATE FILE: `only35.lrplugin/Only35Utils.lua`\n\n```lua\n--[[----------------------------------------------------------------------------\n    Only35 Utilities Module\n    \n    Constants, configuration, and helper functions used across the plugin.\n------------------------------------------------------------------------------]]\n\nlocal LrLogger = import 'LrLogger'\n\nlocal Only35Utils = {}\n\n--------------------------------------------------------------------------------\n-- API Configuration\n--------------------------------------------------------------------------------\n\nOnly35Utils.API_BASE_URL = \"https://api.only35.com\"\nOnly35Utils.WEB_BASE_URL = \"https://only35.com\"\n\n--------------------------------------------------------------------------------\n-- OAuth Configuration\n--------------------------------------------------------------------------------\n\nOnly35Utils.CLIENT_ID = \"lightroom\"\nOnly35Utils.REDIRECT_URI = \"https://only35.com/oauth/success\"\n\nOnly35Utils.SCOPES = {\n    \"photos:read\",\n    \"photos:write\",\n    \"rolls:read\",\n    \"rolls:write\",\n}\n\n-- Scopes as space-separated string for OAuth URL\nOnly35Utils.SCOPES_STRING = table.concat(Only35Utils.SCOPES, \" \")\n\n--------------------------------------------------------------------------------\n-- API Endpoints\n--------------------------------------------------------------------------------\n\nOnly35Utils.ENDPOINTS = {\n    -- OAuth endpoints (relative to WEB_BASE_URL)\n    AUTHORIZE = \"/oauth/authorize\",\n    \n    -- API endpoints (relative to API_BASE_URL)\n    TOKEN = \"/oauth/token\",\n    REVOKE = \"/oauth/revoke\",\n    UPLOAD_URL = \"/photographs/upload-url\",\n    PHOTOGRAPHS = \"/photographs\",\n    ROLLS = \"/rolls\",\n}\n\n--------------------------------------------------------------------------------\n-- Helper Functions\n--------------------------------------------------------------------------------\n\n--- Generate a random alphanumeric string for CSRF state parameter\n-- @param length Number of characters to generate (default: 32)\n-- @return Random alphanumeric string\nfunction Only35Utils.generateRandomString(length)\n    length = length or 32\n    local chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    local result = \"\"\n    \n    -- Seed random number generator with current time\n    math.randomseed(os.time())\n    \n    for i = 1, length do\n        local idx = math.random(1, #chars)\n        result = result .. chars:sub(idx, idx)\n    end\n    \n    return result\nend\n\n--------------------------------------------------------------------------------\n-- Logging\n--------------------------------------------------------------------------------\n\nlocal logger = LrLogger('Only35Plugin')\nlogger:enable(\"logfile\")\n\n--- Log a debug message\n-- @param message The message to log\nfunction Only35Utils.log(message)\n    logger:trace(message)\nend\n\n--- Log an info message\n-- @param message The message to log\nfunction Only35Utils.logInfo(message)\n    logger:info(message)\nend\n\n--- Log a warning message\n-- @param message The message to log\nfunction Only35Utils.logWarn(message)\n    logger:warn(message)\nend\n\n--- Log an error message\n-- @param message The message to log\nfunction Only35Utils.logError(message)\n    logger:error(message)\nend\n\n--------------------------------------------------------------------------------\n-- URL Helpers\n--------------------------------------------------------------------------------\n\n--- Build full API URL from endpoint\n-- @param endpoint Endpoint key from ENDPOINTS table or path string\n-- @return Full API URL\nfunction Only35Utils.apiUrl(endpoint)\n    local path = Only35Utils.ENDPOINTS[endpoint] or endpoint\n    return Only35Utils.API_BASE_URL .. path\nend\n\n--- Build full web URL from endpoint\n-- @param endpoint Endpoint key from ENDPOINTS table or path string\n-- @return Full web URL\nfunction Only35Utils.webUrl(endpoint)\n    local path = Only35Utils.ENDPOINTS[endpoint] or endpoint\n    return Only35Utils.WEB_BASE_URL .. path\nend\n\nreturn Only35Utils\n```\n\n## Exit Criteria\n\n```bash\n# File exists\ntest -f only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: Only35Utils.lua exists\" || echo \"FAIL: Only35Utils.lua missing\"\n\n# Check for required constants\ngrep -q 'API_BASE_URL = \"https://api.only35.com\"' only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: API_BASE_URL correct\" || echo \"FAIL: API_BASE_URL wrong\"\ngrep -q 'WEB_BASE_URL = \"https://only35.com\"' only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: WEB_BASE_URL correct\" || echo \"FAIL: WEB_BASE_URL wrong\"\ngrep -q 'CLIENT_ID = \"lightroom\"' only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: CLIENT_ID correct\" || echo \"FAIL: CLIENT_ID wrong\"\ngrep -q 'REDIRECT_URI = \"https://only35.com/oauth/success\"' only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: REDIRECT_URI correct\" || echo \"FAIL: REDIRECT_URI wrong\"\n\n# Check for SCOPES\ngrep -q '\"photos:read\"' only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: SCOPES includes photos:read\" || echo \"FAIL: SCOPES missing photos:read\"\ngrep -q '\"photos:write\"' only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: SCOPES includes photos:write\" || echo \"FAIL: SCOPES missing photos:write\"\n\n# Check for ENDPOINTS\ngrep -q 'AUTHORIZE = \"/oauth/authorize\"' only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: AUTHORIZE endpoint correct\" || echo \"FAIL: AUTHORIZE endpoint wrong\"\ngrep -q 'TOKEN = \"/oauth/token\"' only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: TOKEN endpoint correct\" || echo \"FAIL: TOKEN endpoint wrong\"\n\n# Check for generateRandomString function\ngrep -q \"function Only35Utils.generateRandomString\" only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: generateRandomString function exists\" || echo \"FAIL: generateRandomString function missing\"\n\n# Lua syntax check\nlua -e \"local ok, err = loadfile('only35.lrplugin/Only35Utils.lua'); if not ok then print('FAIL: ' .. err); os.exit(1) else print('PASS: Lua syntax valid') end\" 2\u003e/dev/null || echo \"PASS: Lua syntax valid (lua not installed, manual check needed)\"\n```\n\n### Verification Checklist\n- [ ] Only35Utils.lua created in only35.lrplugin/\n- [ ] API_BASE_URL = \"https://api.only35.com\"\n- [ ] WEB_BASE_URL = \"https://only35.com\"\n- [ ] CLIENT_ID = \"lightroom\"\n- [ ] REDIRECT_URI = \"https://only35.com/oauth/success\"\n- [ ] SCOPES table with all 4 scopes\n- [ ] ENDPOINTS table with all 6 endpoints\n- [ ] generateRandomString(length) function implemented\n- [ ] Logging functions implemented\n- [ ] Lua syntax is valid\n\n## Files to Modify\n\n- `only35.lrplugin/Only35Utils.lua` (CREATE) - Utilities module with constants and helpers","status":"closed","priority":0,"issue_type":"task","owner":"carlo.nicora@gmail.com","created_at":"2026-01-20T08:53:14.400293+01:00","created_by":"Carlo Nicora","updated_at":"2026-01-20T09:04:20.231793+01:00","closed_at":"2026-01-20T09:04:20.231793+01:00","close_reason":"Done: Created Only35Utils.lua with all constants, endpoints, and helper functions","labels":["openspec:lightroom-plugin"],"dependencies":[{"issue_id":"only35.lightroom-utt.2","depends_on_id":"only35.lightroom-utt","type":"parent-child","created_at":"2026-01-20T08:53:14.401104+01:00","created_by":"Carlo Nicora"}]}
{"id":"only35.lightroom-utt.3","title":"Implement OAuth Authentication Module (Only35Auth.lua)","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/lightroom-plugin/\n**Task**: 2.1 OAuth Module from tasks.md\n**Depends On**: Task 1.2 (Utils needed for constants)\n\n## Requirements\n\nImplement the OAuth 2.0 authentication module that handles the complete auth flow.\n\n**OAuth Flow:**\n1. startOAuthFlow() - Opens browser with auth URL, shows code entry dialog\n2. User logs in on Only35 web, copies authorization code\n3. exchangeCodeForTokens() - POSTs code to /oauth/token endpoint\n4. Tokens stored in LrPrefs for persistence\n\n**Token Management:**\n- storeTokens(tokens) - Save access_token, refresh_token, expiry to LrPrefs\n- getAccessToken() - Return current access token (refresh if needed)\n- isTokenValid() - Check if token exists and not expired (60s buffer)\n- refreshAccessToken() - Use refresh_token to get new access_token\n- clearTokens() - Remove all tokens (logout)\n\n**Token Storage Keys (in LrPrefs):**\n- only35_access_token\n- only35_refresh_token\n- only35_token_expiry (unix timestamp)\n- only35_user_id\n- only35_company_id\n\n**Error Handling:**\n- Show user-friendly error dialogs on auth failure\n- Clear tokens on refresh failure\n- Log all auth events for debugging\n\n## Reference Implementation\n\nCREATE FILE: `only35.lrplugin/Only35Auth.lua`\n\n```lua\n--[[----------------------------------------------------------------------------\n    Only35 OAuth Authentication Module\n    \n    Handles OAuth 2.0 authentication flow, token storage, and refresh.\n------------------------------------------------------------------------------]]\n\nlocal LrHttp = import 'LrHttp'\nlocal LrDialogs = import 'LrDialogs'\nlocal LrTasks = import 'LrTasks'\nlocal LrPrefs = import 'LrPrefs'\nlocal LrFunctionContext = import 'LrFunctionContext'\nlocal LrBinding = import 'LrBinding'\nlocal LrView = import 'LrView'\n\nlocal Only35Utils = require 'Only35Utils'\n\nlocal Only35Auth = {}\n\n--------------------------------------------------------------------------------\n-- Token Storage Keys\n--------------------------------------------------------------------------------\n\nlocal TOKEN_KEYS = {\n    ACCESS_TOKEN = \"only35_access_token\",\n    REFRESH_TOKEN = \"only35_refresh_token\",\n    TOKEN_EXPIRY = \"only35_token_expiry\",\n    USER_ID = \"only35_user_id\",\n    COMPANY_ID = \"only35_company_id\",\n}\n\n--------------------------------------------------------------------------------\n-- Token Storage Functions\n--------------------------------------------------------------------------------\n\n--- Store tokens in Lightroom preferences\n-- @param tokens Table with access_token, refresh_token, expires_in, user_id, company_id\nfunction Only35Auth.storeTokens(tokens)\n    local prefs = LrPrefs.prefsForPlugin()\n    \n    prefs[TOKEN_KEYS.ACCESS_TOKEN] = tokens.access_token\n    prefs[TOKEN_KEYS.REFRESH_TOKEN] = tokens.refresh_token\n    prefs[TOKEN_KEYS.TOKEN_EXPIRY] = os.time() + (tokens.expires_in or 3600)\n    \n    if tokens.user_id then\n        prefs[TOKEN_KEYS.USER_ID] = tokens.user_id\n    end\n    if tokens.company_id then\n        prefs[TOKEN_KEYS.COMPANY_ID] = tokens.company_id\n    end\n    \n    Only35Utils.logInfo(\"Tokens stored successfully\")\nend\n\n--- Clear all stored tokens (logout)\nfunction Only35Auth.clearTokens()\n    local prefs = LrPrefs.prefsForPlugin()\n    \n    prefs[TOKEN_KEYS.ACCESS_TOKEN] = nil\n    prefs[TOKEN_KEYS.REFRESH_TOKEN] = nil\n    prefs[TOKEN_KEYS.TOKEN_EXPIRY] = nil\n    prefs[TOKEN_KEYS.USER_ID] = nil\n    prefs[TOKEN_KEYS.COMPANY_ID] = nil\n    \n    Only35Utils.logInfo(\"Tokens cleared\")\nend\n\n--- Check if current token is valid\n-- @return boolean True if token exists and not expired (with 60s buffer)\nfunction Only35Auth.isTokenValid()\n    local prefs = LrPrefs.prefsForPlugin()\n    local accessToken = prefs[TOKEN_KEYS.ACCESS_TOKEN]\n    local expiry = prefs[TOKEN_KEYS.TOKEN_EXPIRY]\n    \n    if not accessToken or not expiry then\n        return false\n    end\n    \n    -- 60 second buffer before expiry\n    return expiry \u003e (os.time() + 60)\nend\n\n--- Get current access token, refreshing if needed\n-- @return string Access token or nil if not authenticated\nfunction Only35Auth.getAccessToken()\n    local prefs = LrPrefs.prefsForPlugin()\n    \n    if Only35Auth.isTokenValid() then\n        return prefs[TOKEN_KEYS.ACCESS_TOKEN]\n    end\n    \n    -- Try to refresh\n    if Only35Auth.refreshAccessToken() then\n        return prefs[TOKEN_KEYS.ACCESS_TOKEN]\n    end\n    \n    return nil\nend\n\n--- Get stored user ID\n-- @return string User ID or nil\nfunction Only35Auth.getUserId()\n    local prefs = LrPrefs.prefsForPlugin()\n    return prefs[TOKEN_KEYS.USER_ID]\nend\n\n--------------------------------------------------------------------------------\n-- OAuth Flow\n--------------------------------------------------------------------------------\n\n--- Show dialog for user to enter authorization code\n-- @return string Authorization code or nil if cancelled\nlocal function showCodeEntryDialog()\n    return LrFunctionContext.callWithContext(\"codeEntry\", function(context)\n        local viewFactory = LrView.osFactory()\n        local propertyTable = LrBinding.makePropertyTable(context)\n        propertyTable.authCode = \"\"\n        \n        local contents = viewFactory:column {\n            spacing = viewFactory:control_spacing(),\n            \n            viewFactory:static_text {\n                title = \"After logging in on Only35, you will see an authorization code.\",\n                wrap = true,\n                width = 400,\n            },\n            \n            viewFactory:static_text {\n                title = \"Please copy and paste that code below:\",\n                wrap = true,\n                width = 400,\n            },\n            \n            viewFactory:spacer { height = 10 },\n            \n            viewFactory:edit_field {\n                value = LrView.bind(\"authCode\"),\n                width_in_chars = 40,\n                immediate = true,\n            },\n        }\n        \n        local result = LrDialogs.presentModalDialog({\n            title = \"Enter Authorization Code\",\n            contents = contents,\n            actionVerb = \"Submit\",\n            cancelVerb = \"Cancel\",\n        })\n        \n        if result == \"ok\" then\n            local code = propertyTable.authCode\n            if code and code ~= \"\" then\n                return code:match(\"^%s*(.-)%s*$\") -- trim whitespace\n            end\n        end\n        \n        return nil\n    end)\nend\n\n--- Start the OAuth flow: open browser and show code entry dialog\n-- @param propertyTable The publish settings property table to update\nfunction Only35Auth.startOAuthFlow(propertyTable)\n    LrTasks.startAsyncTask(function()\n        Only35Utils.logInfo(\"Starting OAuth flow\")\n        \n        -- Generate state parameter for CSRF protection\n        local state = Only35Utils.generateRandomString(32)\n        \n        -- Build authorization URL\n        local authUrl = Only35Utils.webUrl(\"AUTHORIZE\") .. \"?\" ..\n            \"client_id=\" .. Only35Utils.CLIENT_ID ..\n            \"\u0026redirect_uri=\" .. LrHttp.urlEncode(Only35Utils.REDIRECT_URI) ..\n            \"\u0026response_type=code\" ..\n            \"\u0026scope=\" .. LrHttp.urlEncode(Only35Utils.SCOPES_STRING) ..\n            \"\u0026state=\" .. state\n        \n        Only35Utils.logInfo(\"Opening browser for authentication\")\n        LrHttp.openUrlInBrowser(authUrl)\n        \n        -- Show dialog for code entry\n        local code = showCodeEntryDialog()\n        \n        if not code or code == \"\" then\n            Only35Utils.logInfo(\"OAuth flow cancelled by user\")\n            return\n        end\n        \n        Only35Utils.logInfo(\"Exchanging authorization code for tokens\")\n        \n        -- Exchange code for tokens\n        local tokens = Only35Auth.exchangeCodeForTokens(code)\n        \n        if tokens then\n            Only35Auth.storeTokens(tokens)\n            \n            -- Update property table for UI\n            propertyTable.isLoggedIn = true\n            propertyTable.loginStatus = \"Logged in\"\n            propertyTable.loginButtonTitle = \"Logout\"\n            \n            if tokens.user_id then\n                propertyTable.loginStatus = \"Logged in as user \" .. tokens.user_id\n            end\n            \n            LrDialogs.message(\"Success\", \"You have been logged in to Only35.\", \"info\")\n        end\n    end)\nend\n\n--- Exchange authorization code for access tokens\n-- @param code Authorization code from OAuth redirect\n-- @return table Tokens table or nil on failure\nfunction Only35Auth.exchangeCodeForTokens(code)\n    local tokenUrl = Only35Utils.apiUrl(\"TOKEN\")\n    \n    local body = \"grant_type=authorization_code\" ..\n        \"\u0026code=\" .. LrHttp.urlEncode(code) ..\n        \"\u0026client_id=\" .. Only35Utils.CLIENT_ID ..\n        \"\u0026redirect_uri=\" .. LrHttp.urlEncode(Only35Utils.REDIRECT_URI)\n    \n    local headers = {\n        { field = \"Content-Type\", value = \"application/x-www-form-urlencoded\" },\n        { field = \"Accept\", value = \"application/json\" },\n    }\n    \n    Only35Utils.logInfo(\"Posting to token endpoint: \" .. tokenUrl)\n    \n    local result, responseHeaders = LrHttp.post(tokenUrl, body, headers)\n    \n    if not result then\n        Only35Utils.logError(\"Token exchange failed: no response\")\n        LrDialogs.showError(\"Could not connect to Only35. Please check your internet connection.\")\n        return nil\n    end\n    \n    local status = responseHeaders.status\n    Only35Utils.logInfo(\"Token endpoint response status: \" .. tostring(status))\n    \n    if status == 200 then\n        local json = require 'json'\n        local tokens = json.decode(result)\n        Only35Utils.logInfo(\"Token exchange successful\")\n        return tokens\n    else\n        Only35Utils.logError(\"Token exchange failed with status: \" .. tostring(status))\n        Only35Utils.logError(\"Response: \" .. tostring(result))\n        LrDialogs.showError(\"Authentication failed. Please try again.\\n\\nError: \" .. tostring(result))\n        return nil\n    end\nend\n\n--- Refresh the access token using the refresh token\n-- @return boolean True if refresh successful\nfunction Only35Auth.refreshAccessToken()\n    local prefs = LrPrefs.prefsForPlugin()\n    local refreshToken = prefs[TOKEN_KEYS.REFRESH_TOKEN]\n    \n    if not refreshToken then\n        Only35Utils.logWarn(\"No refresh token available\")\n        return false\n    end\n    \n    Only35Utils.logInfo(\"Refreshing access token\")\n    \n    local tokenUrl = Only35Utils.apiUrl(\"TOKEN\")\n    \n    local body = \"grant_type=refresh_token\" ..\n        \"\u0026refresh_token=\" .. LrHttp.urlEncode(refreshToken) ..\n        \"\u0026client_id=\" .. Only35Utils.CLIENT_ID\n    \n    local headers = {\n        { field = \"Content-Type\", value = \"application/x-www-form-urlencoded\" },\n        { field = \"Accept\", value = \"application/json\" },\n    }\n    \n    local result, responseHeaders = LrHttp.post(tokenUrl, body, headers)\n    \n    if not result then\n        Only35Utils.logError(\"Token refresh failed: no response\")\n        Only35Auth.clearTokens()\n        return false\n    end\n    \n    local status = responseHeaders.status\n    \n    if status == 200 then\n        local json = require 'json'\n        local tokens = json.decode(result)\n        Only35Auth.storeTokens(tokens)\n        Only35Utils.logInfo(\"Token refresh successful\")\n        return true\n    else\n        Only35Utils.logError(\"Token refresh failed with status: \" .. tostring(status))\n        Only35Auth.clearTokens()\n        return false\n    end\nend\n\n--- Logout: clear tokens and optionally revoke on server\n-- @param propertyTable The publish settings property table to update\nfunction Only35Auth.logout(propertyTable)\n    LrTasks.startAsyncTask(function()\n        Only35Utils.logInfo(\"Logging out\")\n        \n        local prefs = LrPrefs.prefsForPlugin()\n        local accessToken = prefs[TOKEN_KEYS.ACCESS_TOKEN]\n        \n        -- Try to revoke token on server (best effort)\n        if accessToken then\n            local revokeUrl = Only35Utils.apiUrl(\"REVOKE\")\n            local body = \"token=\" .. LrHttp.urlEncode(accessToken)\n            local headers = {\n                { field = \"Content-Type\", value = \"application/x-www-form-urlencoded\" },\n            }\n            \n            -- Fire and forget - don't wait for response\n            pcall(function()\n                LrHttp.post(revokeUrl, body, headers)\n            end)\n        end\n        \n        -- Clear local tokens\n        Only35Auth.clearTokens()\n        \n        -- Update UI\n        propertyTable.isLoggedIn = false\n        propertyTable.loginStatus = \"Not logged in\"\n        propertyTable.loginButtonTitle = \"Login\"\n        \n        LrDialogs.message(\"Logged Out\", \"You have been logged out of Only35.\", \"info\")\n    end)\nend\n\n--- Check if user is currently logged in\n-- @return boolean True if logged in with valid token\nfunction Only35Auth.isLoggedIn()\n    return Only35Auth.isTokenValid() or Only35Auth.refreshAccessToken()\nend\n\nreturn Only35Auth\n```\n\nCREATE FILE: `only35.lrplugin/json.lua`\n\nNote: You need a JSON library for Lua. Use a lightweight implementation like dkjson or create a minimal one. For Lightroom, you can use the following pattern or include a JSON library:\n\n```lua\n--[[----------------------------------------------------------------------------\n    Minimal JSON Encoder/Decoder for Lightroom\n    \n    Based on public domain JSON implementations.\n    Only handles the subset needed for Only35 API.\n------------------------------------------------------------------------------]]\n\nlocal json = {}\n\n-- Encode a Lua value to JSON string\nfunction json.encode(val)\n    local t = type(val)\n    \n    if val == nil then\n        return \"null\"\n    elseif t == \"boolean\" then\n        return val and \"true\" or \"false\"\n    elseif t == \"number\" then\n        return tostring(val)\n    elseif t == \"string\" then\n        -- Escape special characters\n        local escaped = val:gsub('\\\\', '\\\\\\\\')\n                           :gsub('\"', '\\\\\"')\n                           :gsub('\\n', '\\\\n')\n                           :gsub('\\r', '\\\\r')\n                           :gsub('\\t', '\\\\t')\n        return '\"' .. escaped .. '\"'\n    elseif t == \"table\" then\n        -- Check if array or object\n        local isArray = true\n        local maxIndex = 0\n        for k, v in pairs(val) do\n            if type(k) ~= \"number\" or k \u003c= 0 or math.floor(k) ~= k then\n                isArray = false\n                break\n            end\n            if k \u003e maxIndex then maxIndex = k end\n        end\n        \n        if isArray and maxIndex == #val then\n            -- Encode as array\n            local parts = {}\n            for i, v in ipairs(val) do\n                table.insert(parts, json.encode(v))\n            end\n            return \"[\" .. table.concat(parts, \",\") .. \"]\"\n        else\n            -- Encode as object\n            local parts = {}\n            for k, v in pairs(val) do\n                table.insert(parts, json.encode(tostring(k)) .. \":\" .. json.encode(v))\n            end\n            return \"{\" .. table.concat(parts, \",\") .. \"}\"\n        end\n    else\n        error(\"Cannot encode type: \" .. t)\n    end\nend\n\n-- Decode a JSON string to Lua value\nfunction json.decode(str)\n    if not str or str == \"\" then\n        return nil\n    end\n    \n    local pos = 1\n    \n    local function skipWhitespace()\n        while pos \u003c= #str and str:sub(pos, pos):match(\"%s\") do\n            pos = pos + 1\n        end\n    end\n    \n    local function parseValue()\n        skipWhitespace()\n        local c = str:sub(pos, pos)\n        \n        if c == '\"' then\n            -- Parse string\n            pos = pos + 1\n            local result = \"\"\n            while pos \u003c= #str do\n                local char = str:sub(pos, pos)\n                if char == '\"' then\n                    pos = pos + 1\n                    return result\n                elseif char == '\\\\' then\n                    pos = pos + 1\n                    local escaped = str:sub(pos, pos)\n                    if escaped == 'n' then result = result .. '\\n'\n                    elseif escaped == 'r' then result = result .. '\\r'\n                    elseif escaped == 't' then result = result .. '\\t'\n                    else result = result .. escaped\n                    end\n                else\n                    result = result .. char\n                end\n                pos = pos + 1\n            end\n            error(\"Unterminated string\")\n            \n        elseif c == '{' then\n            -- Parse object\n            pos = pos + 1\n            local result = {}\n            skipWhitespace()\n            if str:sub(pos, pos) == '}' then\n                pos = pos + 1\n                return result\n            end\n            while true do\n                skipWhitespace()\n                local key = parseValue()\n                skipWhitespace()\n                if str:sub(pos, pos) ~= ':' then\n                    error(\"Expected ':' in object\")\n                end\n                pos = pos + 1\n                result[key] = parseValue()\n                skipWhitespace()\n                local sep = str:sub(pos, pos)\n                if sep == '}' then\n                    pos = pos + 1\n                    return result\n                elseif sep == ',' then\n                    pos = pos + 1\n                else\n                    error(\"Expected ',' or '}' in object\")\n                end\n            end\n            \n        elseif c == '[' then\n            -- Parse array\n            pos = pos + 1\n            local result = {}\n            skipWhitespace()\n            if str:sub(pos, pos) == ']' then\n                pos = pos + 1\n                return result\n            end\n            while true do\n                table.insert(result, parseValue())\n                skipWhitespace()\n                local sep = str:sub(pos, pos)\n                if sep == ']' then\n                    pos = pos + 1\n                    return result\n                elseif sep == ',' then\n                    pos = pos + 1\n                else\n                    error(\"Expected ',' or ']' in array\")\n                end\n            end\n            \n        elseif str:sub(pos, pos + 3) == \"true\" then\n            pos = pos + 4\n            return true\n            \n        elseif str:sub(pos, pos + 4) == \"false\" then\n            pos = pos + 5\n            return false\n            \n        elseif str:sub(pos, pos + 3) == \"null\" then\n            pos = pos + 4\n            return nil\n            \n        elseif c:match(\"[%d%-]\") then\n            -- Parse number\n            local startPos = pos\n            if str:sub(pos, pos) == '-' then pos = pos + 1 end\n            while pos \u003c= #str and str:sub(pos, pos):match(\"%d\") do\n                pos = pos + 1\n            end\n            if pos \u003c= #str and str:sub(pos, pos) == '.' then\n                pos = pos + 1\n                while pos \u003c= #str and str:sub(pos, pos):match(\"%d\") do\n                    pos = pos + 1\n                end\n            end\n            if pos \u003c= #str and str:sub(pos, pos):lower() == 'e' then\n                pos = pos + 1\n                if str:sub(pos, pos):match(\"[%+%-]\") then pos = pos + 1 end\n                while pos \u003c= #str and str:sub(pos, pos):match(\"%d\") do\n                    pos = pos + 1\n                end\n            end\n            return tonumber(str:sub(startPos, pos - 1))\n        else\n            error(\"Unexpected character at position \" .. pos .. \": \" .. c)\n        end\n    end\n    \n    local result = parseValue()\n    skipWhitespace()\n    return result\nend\n\nreturn json\n```\n\n## Exit Criteria\n\n```bash\n# File exists\ntest -f only35.lrplugin/Only35Auth.lua \u0026\u0026 echo \"PASS: Only35Auth.lua exists\" || echo \"FAIL: Only35Auth.lua missing\"\ntest -f only35.lrplugin/json.lua \u0026\u0026 echo \"PASS: json.lua exists\" || echo \"FAIL: json.lua missing\"\n\n# Check for required functions\ngrep -q \"function Only35Auth.startOAuthFlow\" only35.lrplugin/Only35Auth.lua \u0026\u0026 echo \"PASS: startOAuthFlow exists\" || echo \"FAIL: startOAuthFlow missing\"\ngrep -q \"function Only35Auth.exchangeCodeForTokens\" only35.lrplugin/Only35Auth.lua \u0026\u0026 echo \"PASS: exchangeCodeForTokens exists\" || echo \"FAIL: exchangeCodeForTokens missing\"\ngrep -q \"function Only35Auth.refreshAccessToken\" only35.lrplugin/Only35Auth.lua \u0026\u0026 echo \"PASS: refreshAccessToken exists\" || echo \"FAIL: refreshAccessToken missing\"\ngrep -q \"function Only35Auth.logout\" only35.lrplugin/Only35Auth.lua \u0026\u0026 echo \"PASS: logout exists\" || echo \"FAIL: logout missing\"\ngrep -q \"function Only35Auth.storeTokens\" only35.lrplugin/Only35Auth.lua \u0026\u0026 echo \"PASS: storeTokens exists\" || echo \"FAIL: storeTokens missing\"\ngrep -q \"function Only35Auth.isTokenValid\" only35.lrplugin/Only35Auth.lua \u0026\u0026 echo \"PASS: isTokenValid exists\" || echo \"FAIL: isTokenValid missing\"\n\n# Check for LrPrefs usage\ngrep -q \"LrPrefs.prefsForPlugin\" only35.lrplugin/Only35Auth.lua \u0026\u0026 echo \"PASS: Uses LrPrefs\" || echo \"FAIL: LrPrefs not used\"\n\n# Check JSON library\ngrep -q \"function json.encode\" only35.lrplugin/json.lua \u0026\u0026 echo \"PASS: json.encode exists\" || echo \"FAIL: json.encode missing\"\ngrep -q \"function json.decode\" only35.lrplugin/json.lua \u0026\u0026 echo \"PASS: json.decode exists\" || echo \"FAIL: json.decode missing\"\n\n# Lua syntax check\nlua -e \"local ok, err = loadfile('only35.lrplugin/Only35Auth.lua'); if not ok then print('FAIL: ' .. err); os.exit(1) else print('PASS: Lua syntax valid') end\" 2\u003e/dev/null || echo \"PASS: Lua syntax valid (lua not installed)\"\n```\n\n### Verification Checklist\n- [ ] Only35Auth.lua created with all functions\n- [ ] startOAuthFlow() opens browser and shows code dialog\n- [ ] exchangeCodeForTokens() POSTs to /oauth/token\n- [ ] refreshAccessToken() handles token refresh\n- [ ] logout() clears tokens and optionally revokes\n- [ ] storeTokens() saves to LrPrefs\n- [ ] isTokenValid() checks expiry with 60s buffer\n- [ ] json.lua created for JSON parsing\n- [ ] Uses Only35Utils for constants\n- [ ] Proper error handling with user dialogs\n- [ ] Lua syntax is valid\n\n## Files to Modify\n\n- `only35.lrplugin/Only35Auth.lua` (CREATE) - OAuth authentication module\n- `only35.lrplugin/json.lua` (CREATE) - JSON encoder/decoder library","status":"closed","priority":1,"issue_type":"task","owner":"carlo.nicora@gmail.com","created_at":"2026-01-20T08:54:48.52933+01:00","created_by":"Carlo Nicora","updated_at":"2026-01-20T09:05:48.37765+01:00","closed_at":"2026-01-20T09:05:48.37765+01:00","close_reason":"Done: Created Only35Auth.lua with OAuth flow, token management, and json.lua for JSON parsing","labels":["openspec:lightroom-plugin"],"dependencies":[{"issue_id":"only35.lightroom-utt.3","depends_on_id":"only35.lightroom-utt","type":"parent-child","created_at":"2026-01-20T08:54:48.530281+01:00","created_by":"Carlo Nicora"},{"issue_id":"only35.lightroom-utt.3","depends_on_id":"only35.lightroom-utt.2","type":"blocks","created_at":"2026-01-20T08:59:16.111633+01:00","created_by":"Carlo Nicora"}]}
{"id":"only35.lightroom-utt.4","title":"Implement API Client Module (Only35API.lua)","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/lightroom-plugin/\n**Task**: 3.1 HTTP Client from tasks.md\n**Depends On**: Task 2.1 (Auth needed for tokens)\n\n## Requirements\n\nImplement the HTTP client module for communicating with the Only35 API.\n\n**HTTP Helpers:**\n- postJson(url, data) - POST JSON with auth headers, return parsed response\n- get(url) - GET with auth headers, return parsed response\n- putBinary(url, filePath, headers) - PUT binary data to URL (for S3)\n\n**API Methods:**\n- getUploadUrl(settings, params) - POST /photographs/upload-url\n  - params: { rollId, filename, contentType }\n  - returns: { url, headers, photographId }\n- uploadToS3(presignedUrl, filePath, headers) - PUT file to S3\n- createPhotograph(settings, photographId, metadata) - POST /photographs\n- updatePhotograph(settings, photographId, metadata) - PATCH /photographs/{id}\n- getRolls(settings) - GET /rolls\n- createRoll(settings, name) - POST /rolls\n\n**Error Handling:**\n- Parse API error responses\n- Retry with exponential backoff on 5xx errors\n- Handle rate limiting (429) with Retry-After header\n- Auto-refresh token on 401\n\n**Headers Required:**\n- Authorization: Bearer {token}\n- Content-Type: application/json (for JSON)\n- Accept: application/vnd.api+json\n\n## Reference Implementation\n\nCREATE FILE: `only35.lrplugin/Only35API.lua`\n\n```lua\n--[[----------------------------------------------------------------------------\n    Only35 API Client Module\n    \n    HTTP client for communicating with the Only35 API.\n    Handles authentication, JSON encoding, and error handling.\n------------------------------------------------------------------------------]]\n\nlocal LrHttp = import 'LrHttp'\nlocal LrDialogs = import 'LrDialogs'\nlocal LrPathUtils = import 'LrPathUtils'\nlocal LrFileUtils = import 'LrFileUtils'\nlocal LrTasks = import 'LrTasks'\n\nlocal Only35Utils = require 'Only35Utils'\nlocal Only35Auth = require 'Only35Auth'\nlocal json = require 'json'\n\nlocal Only35API = {}\n\n--------------------------------------------------------------------------------\n-- HTTP Helpers\n--------------------------------------------------------------------------------\n\n--- Make a POST request with JSON body\n-- @param url Full URL to POST to\n-- @param data Table to encode as JSON body\n-- @param retryCount Current retry attempt (internal)\n-- @return table Parsed JSON response\nfunction Only35API.postJson(url, data, retryCount)\n    retryCount = retryCount or 0\n    local maxRetries = 3\n    \n    local token = Only35Auth.getAccessToken()\n    if not token then\n        error(\"Not authenticated. Please log in first.\")\n    end\n    \n    local headers = {\n        { field = \"Authorization\", value = \"Bearer \" .. token },\n        { field = \"Content-Type\", value = \"application/json\" },\n        { field = \"Accept\", value = \"application/vnd.api+json\" },\n    }\n    \n    local body = json.encode(data)\n    \n    Only35Utils.logInfo(\"POST \" .. url)\n    Only35Utils.log(\"Request body: \" .. body)\n    \n    local result, responseHeaders = LrHttp.post(url, body, headers)\n    \n    if not result then\n        if retryCount \u003c maxRetries then\n            Only35Utils.logWarn(\"No response, retrying... (\" .. (retryCount + 1) .. \"/\" .. maxRetries .. \")\")\n            LrTasks.sleep(2 ^ retryCount) -- Exponential backoff\n            return Only35API.postJson(url, data, retryCount + 1)\n        end\n        error(\"Network error: no response from server\")\n    end\n    \n    local status = responseHeaders.status\n    Only35Utils.logInfo(\"Response status: \" .. tostring(status))\n    \n    -- Handle 401 Unauthorized - try token refresh\n    if status == 401 then\n        Only35Utils.logWarn(\"Got 401, attempting token refresh\")\n        if Only35Auth.refreshAccessToken() then\n            return Only35API.postJson(url, data, 0)\n        end\n        error(\"Authentication expired. Please log in again.\")\n    end\n    \n    -- Handle rate limiting\n    if status == 429 then\n        local retryAfter = 60 -- Default to 60 seconds\n        for _, header in ipairs(responseHeaders) do\n            if header.field:lower() == \"retry-after\" then\n                retryAfter = tonumber(header.value) or 60\n                break\n            end\n        end\n        Only35Utils.logWarn(\"Rate limited, waiting \" .. retryAfter .. \" seconds\")\n        LrTasks.sleep(retryAfter)\n        return Only35API.postJson(url, data, retryCount)\n    end\n    \n    -- Handle server errors with retry\n    if status \u003e= 500 and retryCount \u003c maxRetries then\n        Only35Utils.logWarn(\"Server error \" .. status .. \", retrying... (\" .. (retryCount + 1) .. \"/\" .. maxRetries .. \")\")\n        LrTasks.sleep(2 ^ retryCount)\n        return Only35API.postJson(url, data, retryCount + 1)\n    end\n    \n    -- Handle client errors\n    if status \u003e= 400 then\n        local errorMsg = \"API error \" .. status\n        pcall(function()\n            local errorBody = json.decode(result)\n            if errorBody.message then\n                errorMsg = errorMsg .. \": \" .. errorBody.message\n            elseif errorBody.error then\n                errorMsg = errorMsg .. \": \" .. errorBody.error\n            end\n        end)\n        Only35Utils.logError(errorMsg)\n        error(errorMsg)\n    end\n    \n    -- Parse successful response\n    if result and result ~= \"\" then\n        return json.decode(result)\n    end\n    \n    return nil\nend\n\n--- Make a PATCH request with JSON body\n-- @param url Full URL to PATCH\n-- @param data Table to encode as JSON body\n-- @return table Parsed JSON response\nfunction Only35API.patchJson(url, data)\n    local token = Only35Auth.getAccessToken()\n    if not token then\n        error(\"Not authenticated. Please log in first.\")\n    end\n    \n    local headers = {\n        { field = \"Authorization\", value = \"Bearer \" .. token },\n        { field = \"Content-Type\", value = \"application/json\" },\n        { field = \"Accept\", value = \"application/vnd.api+json\" },\n    }\n    \n    local body = json.encode(data)\n    \n    Only35Utils.logInfo(\"PATCH \" .. url)\n    \n    -- LrHttp doesn't support PATCH directly, use POST with X-HTTP-Method-Override\n    table.insert(headers, { field = \"X-HTTP-Method-Override\", value = \"PATCH\" })\n    \n    local result, responseHeaders = LrHttp.post(url, body, headers)\n    \n    if not result then\n        error(\"Network error: no response from server\")\n    end\n    \n    local status = responseHeaders.status\n    \n    if status == 401 then\n        if Only35Auth.refreshAccessToken() then\n            return Only35API.patchJson(url, data)\n        end\n        error(\"Authentication expired. Please log in again.\")\n    end\n    \n    if status \u003e= 400 then\n        local errorMsg = \"API error \" .. status\n        pcall(function()\n            local errorBody = json.decode(result)\n            if errorBody.message then\n                errorMsg = errorMsg .. \": \" .. errorBody.message\n            end\n        end)\n        error(errorMsg)\n    end\n    \n    if result and result ~= \"\" then\n        return json.decode(result)\n    end\n    \n    return nil\nend\n\n--- Make a GET request\n-- @param url Full URL to GET\n-- @return table Parsed JSON response\nfunction Only35API.get(url)\n    local token = Only35Auth.getAccessToken()\n    if not token then\n        error(\"Not authenticated. Please log in first.\")\n    end\n    \n    local headers = {\n        { field = \"Authorization\", value = \"Bearer \" .. token },\n        { field = \"Accept\", value = \"application/vnd.api+json\" },\n    }\n    \n    Only35Utils.logInfo(\"GET \" .. url)\n    \n    local result, responseHeaders = LrHttp.get(url, headers)\n    \n    if not result then\n        error(\"Network error: no response from server\")\n    end\n    \n    local status = responseHeaders.status\n    \n    if status == 401 then\n        if Only35Auth.refreshAccessToken() then\n            return Only35API.get(url)\n        end\n        error(\"Authentication expired. Please log in again.\")\n    end\n    \n    if status \u003e= 400 then\n        local errorMsg = \"API error \" .. status\n        pcall(function()\n            local errorBody = json.decode(result)\n            if errorBody.message then\n                errorMsg = errorMsg .. \": \" .. errorBody.message\n            end\n        end)\n        error(errorMsg)\n    end\n    \n    if result and result ~= \"\" then\n        return json.decode(result)\n    end\n    \n    return nil\nend\n\n--------------------------------------------------------------------------------\n-- S3 Upload\n--------------------------------------------------------------------------------\n\n--- Upload a file to S3 using a presigned URL\n-- @param presignedUrl The presigned S3 PUT URL\n-- @param filePath Local path to the file\n-- @param uploadHeaders Headers required for the upload (from getUploadUrl)\nfunction Only35API.uploadToS3(presignedUrl, filePath, uploadHeaders)\n    Only35Utils.logInfo(\"Uploading to S3: \" .. LrPathUtils.leafName(filePath))\n    \n    -- Read file content\n    local file = io.open(filePath, \"rb\")\n    if not file then\n        error(\"Could not open file: \" .. filePath)\n    end\n    local content = file:read(\"*all\")\n    file:close()\n    \n    -- Build headers\n    local headers = {}\n    if uploadHeaders then\n        for key, value in pairs(uploadHeaders) do\n            table.insert(headers, { field = key, value = value })\n        end\n    end\n    \n    -- S3 PUT request\n    local result, responseHeaders = LrHttp.post(presignedUrl, content, headers, \"PUT\")\n    \n    local status = responseHeaders.status\n    Only35Utils.logInfo(\"S3 upload response status: \" .. tostring(status))\n    \n    if status ~= 200 and status ~= 204 then\n        Only35Utils.logError(\"S3 upload failed with status: \" .. tostring(status))\n        Only35Utils.logError(\"Response: \" .. tostring(result))\n        error(\"Failed to upload photo to storage. Status: \" .. status)\n    end\n    \n    Only35Utils.logInfo(\"S3 upload successful\")\nend\n\n--------------------------------------------------------------------------------\n-- API Methods\n--------------------------------------------------------------------------------\n\n--- Get a presigned upload URL for a photo\n-- @param publishSettings The publish settings table\n-- @param params Table with rollId, filename, contentType\n-- @return table { url, headers, photographId }\nfunction Only35API.getUploadUrl(publishSettings, params)\n    local url = Only35Utils.apiUrl(\"UPLOAD_URL\")\n    \n    local data = {\n        rollId = params.rollId,\n        filename = params.filename,\n        contentType = params.contentType or \"image/jpeg\",\n    }\n    \n    local response = Only35API.postJson(url, data)\n    \n    if not response or not response.url then\n        error(\"Invalid upload URL response from server\")\n    end\n    \n    return {\n        url = response.url,\n        headers = response.headers or {},\n        photographId = response.photographId,\n        key = response.key,\n    }\nend\n\n--- Create a photograph record after upload\n-- @param publishSettings The publish settings table\n-- @param photographId The photograph ID from getUploadUrl\n-- @param metadata Photo metadata table\n-- @return string The created photograph ID\nfunction Only35API.createPhotograph(publishSettings, photographId, metadata)\n    local url = Only35Utils.apiUrl(\"PHOTOGRAPHS\")\n    \n    local data = {\n        id = photographId,\n        rollId = publishSettings.only35_roll_id,\n        stars = metadata.stars,\n        selected = metadata.selected,\n        keywords = metadata.keywords,\n        description = metadata.description,\n        capturedAt = metadata.capturedAt,\n        location = metadata.location,\n    }\n    \n    local response = Only35API.postJson(url, data)\n    \n    if response and response.id then\n        return response.id\n    end\n    \n    return photographId\nend\n\n--- Update an existing photograph's metadata\n-- @param publishSettings The publish settings table\n-- @param photographId The photograph ID to update\n-- @param metadata Updated metadata table\nfunction Only35API.updatePhotograph(publishSettings, photographId, metadata)\n    local url = Only35Utils.apiUrl(\"PHOTOGRAPHS\") .. \"/\" .. photographId\n    \n    local data = {\n        stars = metadata.stars,\n        selected = metadata.selected,\n        keywords = metadata.keywords,\n        description = metadata.description,\n    }\n    \n    Only35API.patchJson(url, data)\nend\n\n--- Delete a photograph\n-- @param publishSettings The publish settings table\n-- @param photographId The photograph ID to delete\nfunction Only35API.deletePhotograph(publishSettings, photographId)\n    -- Use POST with X-HTTP-Method-Override for DELETE\n    local url = Only35Utils.apiUrl(\"PHOTOGRAPHS\") .. \"/\" .. photographId\n    \n    local token = Only35Auth.getAccessToken()\n    if not token then\n        error(\"Not authenticated\")\n    end\n    \n    local headers = {\n        { field = \"Authorization\", value = \"Bearer \" .. token },\n        { field = \"X-HTTP-Method-Override\", value = \"DELETE\" },\n    }\n    \n    local result, responseHeaders = LrHttp.post(url, \"\", headers)\n    \n    if responseHeaders.status \u003e= 400 and responseHeaders.status ~= 404 then\n        Only35Utils.logWarn(\"Failed to delete photograph \" .. photographId)\n    end\nend\n\n--- Get list of rolls\n-- @param publishSettings The publish settings table\n-- @return table Array of roll objects\nfunction Only35API.getRolls(publishSettings)\n    local url = Only35Utils.apiUrl(\"ROLLS\")\n    \n    local response = Only35API.get(url)\n    \n    if response and response.data then\n        return response.data\n    elseif response and type(response) == \"table\" then\n        return response\n    end\n    \n    return {}\nend\n\n--- Create a new roll\n-- @param publishSettings The publish settings table\n-- @param name Name for the new roll\n-- @return table The created roll object\nfunction Only35API.createRoll(publishSettings, name)\n    local url = Only35Utils.apiUrl(\"ROLLS\")\n    \n    local data = {\n        name = name,\n    }\n    \n    local response = Only35API.postJson(url, data)\n    \n    return response\nend\n\n--- Refresh the rolls list and update property table\n-- @param propertyTable The property table to update with roll list\nfunction Only35API.refreshRolls(propertyTable)\n    local rolls = Only35API.getRolls(propertyTable)\n    \n    local rollItems = {}\n    table.insert(rollItems, { title = \"-- Select a Roll --\", value = nil })\n    \n    for _, roll in ipairs(rolls) do\n        table.insert(rollItems, {\n            title = roll.name or roll.id,\n            value = roll.id,\n        })\n    end\n    \n    propertyTable.availableRolls = rollItems\nend\n\nreturn Only35API\n```\n\n## Exit Criteria\n\n```bash\n# File exists\ntest -f only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Only35API.lua exists\" || echo \"FAIL: Only35API.lua missing\"\n\n# Check for HTTP helper functions\ngrep -q \"function Only35API.postJson\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: postJson exists\" || echo \"FAIL: postJson missing\"\ngrep -q \"function Only35API.patchJson\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: patchJson exists\" || echo \"FAIL: patchJson missing\"\ngrep -q \"function Only35API.get\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: get exists\" || echo \"FAIL: get missing\"\ngrep -q \"function Only35API.uploadToS3\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: uploadToS3 exists\" || echo \"FAIL: uploadToS3 missing\"\n\n# Check for API methods\ngrep -q \"function Only35API.getUploadUrl\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: getUploadUrl exists\" || echo \"FAIL: getUploadUrl missing\"\ngrep -q \"function Only35API.createPhotograph\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: createPhotograph exists\" || echo \"FAIL: createPhotograph missing\"\ngrep -q \"function Only35API.updatePhotograph\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: updatePhotograph exists\" || echo \"FAIL: updatePhotograph missing\"\ngrep -q \"function Only35API.getRolls\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: getRolls exists\" || echo \"FAIL: getRolls missing\"\ngrep -q \"function Only35API.createRoll\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: createRoll exists\" || echo \"FAIL: createRoll missing\"\n\n# Check for error handling patterns\ngrep -q \"status == 401\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Handles 401 Unauthorized\" || echo \"FAIL: Missing 401 handling\"\ngrep -q \"status == 429\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Handles rate limiting\" || echo \"FAIL: Missing rate limit handling\"\ngrep -q \"status \u003e= 500\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Handles server errors\" || echo \"FAIL: Missing server error handling\"\n\n# Check for auth integration\ngrep -q \"Only35Auth.getAccessToken\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Uses auth module\" || echo \"FAIL: Auth module not used\"\n\n# Lua syntax check\nlua -e \"local ok, err = loadfile('only35.lrplugin/Only35API.lua'); if not ok then print('FAIL: ' .. err); os.exit(1) else print('PASS: Lua syntax valid') end\" 2\u003e/dev/null || echo \"PASS: Lua syntax valid (lua not installed)\"\n```\n\n### Verification Checklist\n- [ ] Only35API.lua created with all functions\n- [ ] postJson() with Authorization header and JSON body\n- [ ] patchJson() for updating resources (using POST with override)\n- [ ] get() with Authorization header\n- [ ] uploadToS3() for presigned URL uploads\n- [ ] getUploadUrl() - POST /photographs/upload-url\n- [ ] createPhotograph() - POST /photographs\n- [ ] updatePhotograph() - PATCH /photographs/{id}\n- [ ] getRolls() - GET /rolls\n- [ ] createRoll() - POST /rolls\n- [ ] Handles 401 with token refresh\n- [ ] Handles 429 rate limiting with Retry-After\n- [ ] Handles 5xx errors with retry and backoff\n- [ ] Uses Only35Auth for tokens\n- [ ] Uses json module for encoding/decoding\n- [ ] Lua syntax is valid\n\n## Files to Modify\n\n- `only35.lrplugin/Only35API.lua` (CREATE) - API client module","status":"closed","priority":1,"issue_type":"task","owner":"carlo.nicora@gmail.com","created_at":"2026-01-20T08:56:04.419504+01:00","created_by":"Carlo Nicora","updated_at":"2026-01-20T09:07:03.759088+01:00","closed_at":"2026-01-20T09:07:03.759088+01:00","close_reason":"Done: Created Only35API.lua with HTTP helpers, API methods, error handling with retry/rate-limiting","labels":["openspec:lightroom-plugin"],"dependencies":[{"issue_id":"only35.lightroom-utt.4","depends_on_id":"only35.lightroom-utt","type":"parent-child","created_at":"2026-01-20T08:56:04.420369+01:00","created_by":"Carlo Nicora"},{"issue_id":"only35.lightroom-utt.4","depends_on_id":"only35.lightroom-utt.3","type":"blocks","created_at":"2026-01-20T08:59:16.16956+01:00","created_by":"Carlo Nicora"}]}
{"id":"only35.lightroom-utt.5","title":"Implement Publish Service Provider (Only35PublishServiceProvider.lua)","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/lightroom-plugin/\n**Task**: 4.1 Service Provider + 4.2 UI Sections + 4.3 Metadata Mapping + 4.4 Export Settings from tasks.md\n**Depends On**: Task 3.1 (API needed for uploads)\n\n## Requirements\n\nImplement the complete Publish Service Provider with all callbacks.\n\n**Core Callbacks:**\n- processRenderedPhotos() - Main upload loop for publishing\n- getCollectionBehaviorInfo() - Collection defaults\n- metadataThatTriggersRepublish() - Which metadata changes trigger republish\n- deletePhotosFromPublishedCollection() - Handle photo deletion\n- renamePublishedCollection() - Handle collection rename\n- deletePublishedCollection() - Handle collection delete\n\n**UI Callbacks:**\n- sectionsForTopOfDialog() - Login/logout UI\n- viewForCollectionSettings() - Roll selection dropdown\n- startDialog() - Initialize dialog state\n\n**Metadata Mapping:**\n| Lightroom Field | Only35 Field | Notes |\n|-----------------|--------------|-------|\n| rating (0-5) | stars | Direct mapping |\n| pickStatus | selected | flagged-\u003etrue, else-\u003efalse |\n| keywords | keywords[] | Array of strings |\n| caption | description | Optional |\n| dateCreated | capturedAt | EXIF date |\n| gps | location | Latitude/longitude |\n\n**Export Settings:**\n- JPEG format, 92% quality\n- Max 4096x4096, longEdge resize\n- sRGB color space\n- Screen sharpening level 2\n- All metadata embedded\n\n## Reference Implementation\n\nCREATE FILE: `only35.lrplugin/Only35PublishServiceProvider.lua`\n\n```lua\n--[[----------------------------------------------------------------------------\n    Only35 Publish Service Provider\n    \n    Main publish service for exporting photos to Only35.\n    Handles the complete publish workflow including UI, export, and upload.\n------------------------------------------------------------------------------]]\n\nlocal LrView = import 'LrView'\nlocal LrBinding = import 'LrBinding'\nlocal LrDialogs = import 'LrDialogs'\nlocal LrPathUtils = import 'LrPathUtils'\nlocal LrTasks = import 'LrTasks'\nlocal LrApplication = import 'LrApplication'\n\nlocal Only35Utils = require 'Only35Utils'\nlocal Only35Auth = require 'Only35Auth'\nlocal Only35API = require 'Only35API'\n\n--------------------------------------------------------------------------------\n-- Export/Publish Service Provider Definition\n--------------------------------------------------------------------------------\n\nlocal publishServiceProvider = {\n    -- Service identification\n    title = \"Only35\",\n    supportsIncrementalPublish = true,\n    small_icon = \"only35_icon.png\",\n    \n    -- Supported features\n    canExportVideo = false,\n    hideSections = { \"exportLocation\", \"fileNaming\" },\n    allowFileFormats = { \"JPEG\" },\n    allowColorSpaces = { \"sRGB\" },\n    \n    -- Export settings presets\n    exportPresetFields = {\n        { key = \"only35_roll_id\", default = nil },\n        { key = \"only35_roll_name\", default = nil },\n        { key = \"only35_create_new_roll\", default = true },\n        { key = \"isLoggedIn\", default = false },\n        { key = \"loginStatus\", default = \"Not logged in\" },\n        { key = \"loginButtonTitle\", default = \"Login\" },\n        { key = \"availableRolls\", default = {} },\n    },\n}\n\n--------------------------------------------------------------------------------\n-- Export Settings (Image Quality)\n--------------------------------------------------------------------------------\n\npublishServiceProvider.exportServiceExportSettings = {\n    LR_format = \"JPEG\",\n    LR_jpeg_quality = 0.92,\n    LR_jpeg_useLimitSize = false,\n    LR_size_doConstrain = true,\n    LR_size_maxWidth = 4096,\n    LR_size_maxHeight = 4096,\n    LR_size_resizeType = \"longEdge\",\n    LR_outputSharpeningOn = true,\n    LR_outputSharpeningMedia = \"screen\",\n    LR_outputSharpeningLevel = 2,\n    LR_useWatermark = false,\n    LR_metadata_keywordOptions = \"lightroomHierarchical\",\n    LR_embeddedMetadataOption = \"all\",\n    LR_export_colorSpace = \"sRGB\",\n    LR_removeLocationMetadata = false,\n}\n\n--------------------------------------------------------------------------------\n-- Dialog Initialization\n--------------------------------------------------------------------------------\n\nfunction publishServiceProvider.startDialog(propertyTable)\n    -- Initialize login state\n    if Only35Auth.isLoggedIn() then\n        propertyTable.isLoggedIn = true\n        propertyTable.loginStatus = \"Logged in\"\n        propertyTable.loginButtonTitle = \"Logout\"\n        \n        local userId = Only35Auth.getUserId()\n        if userId then\n            propertyTable.loginStatus = \"Logged in as user \" .. userId\n        end\n        \n        -- Fetch rolls\n        LrTasks.startAsyncTask(function()\n            pcall(function()\n                Only35API.refreshRolls(propertyTable)\n            end)\n        end)\n    else\n        propertyTable.isLoggedIn = false\n        propertyTable.loginStatus = \"Not logged in\"\n        propertyTable.loginButtonTitle = \"Login\"\n    end\nend\n\n--------------------------------------------------------------------------------\n-- UI: Top of Dialog (Login Section)\n--------------------------------------------------------------------------------\n\nfunction publishServiceProvider.sectionsForTopOfDialog(viewFactory, propertyTable)\n    return {\n        {\n            title = \"Only35 Account\",\n            synopsis = LrView.bind(\"loginStatus\"),\n            \n            viewFactory:row {\n                spacing = viewFactory:control_spacing(),\n                \n                viewFactory:static_text {\n                    title = \"Status:\",\n                    width = 80,\n                    alignment = \"right\",\n                },\n                \n                viewFactory:static_text {\n                    title = LrView.bind(\"loginStatus\"),\n                    fill_horizontal = 1,\n                    text_color = LrView.bind({\n                        key = \"isLoggedIn\",\n                        transform = function(value)\n                            return value and LrColor(0, 0.5, 0) or LrColor(0.5, 0, 0)\n                        end,\n                    }),\n                },\n            },\n            \n            viewFactory:row {\n                spacing = viewFactory:control_spacing(),\n                \n                viewFactory:static_text {\n                    title = \"\",\n                    width = 80,\n                },\n                \n                viewFactory:push_button {\n                    title = LrView.bind(\"loginButtonTitle\"),\n                    width = 100,\n                    action = function(button)\n                        if propertyTable.isLoggedIn then\n                            Only35Auth.logout(propertyTable)\n                        else\n                            Only35Auth.startOAuthFlow(propertyTable)\n                        end\n                    end,\n                },\n            },\n        },\n    }\nend\n\n--------------------------------------------------------------------------------\n-- UI: Collection Settings (Roll Selection)\n--------------------------------------------------------------------------------\n\nfunction publishServiceProvider.viewForCollectionSettings(viewFactory, propertyTable, info)\n    return viewFactory:column {\n        spacing = viewFactory:control_spacing(),\n        \n        viewFactory:row {\n            spacing = viewFactory:control_spacing(),\n            \n            viewFactory:static_text {\n                title = \"Roll:\",\n                width = 80,\n                alignment = \"right\",\n            },\n            \n            viewFactory:popup_menu {\n                items = LrView.bind(\"availableRolls\"),\n                value = LrView.bind(\"only35_roll_id\"),\n                width = 200,\n                enabled = LrView.bind(\"isLoggedIn\"),\n            },\n            \n            viewFactory:push_button {\n                title = \"Refresh\",\n                enabled = LrView.bind(\"isLoggedIn\"),\n                action = function(button)\n                    LrTasks.startAsyncTask(function()\n                        local success, err = pcall(function()\n                            Only35API.refreshRolls(propertyTable)\n                        end)\n                        if not success then\n                            LrDialogs.showError(\"Failed to refresh rolls: \" .. tostring(err))\n                        end\n                    end)\n                end,\n            },\n        },\n        \n        viewFactory:row {\n            spacing = viewFactory:control_spacing(),\n            \n            viewFactory:static_text {\n                title = \"\",\n                width = 80,\n            },\n            \n            viewFactory:checkbox {\n                title = \"Create new roll if none selected\",\n                value = LrView.bind(\"only35_create_new_roll\"),\n                enabled = LrView.bind(\"isLoggedIn\"),\n            },\n        },\n        \n        viewFactory:row {\n            spacing = viewFactory:control_spacing(),\n            \n            viewFactory:static_text {\n                title = \"\",\n                width = 80,\n            },\n            \n            viewFactory:edit_field {\n                value = LrView.bind(\"only35_roll_name\"),\n                placeholder_string = \"New roll name (optional)\",\n                width = 200,\n                enabled = LrView.bind({\n                    keys = { \"isLoggedIn\", \"only35_create_new_roll\", \"only35_roll_id\" },\n                    operation = function(binder, values, fromTable)\n                        return values.isLoggedIn and values.only35_create_new_roll and not values.only35_roll_id\n                    end,\n                }),\n            },\n        },\n    }\nend\n\n--------------------------------------------------------------------------------\n-- Collection Behavior\n--------------------------------------------------------------------------------\n\nfunction publishServiceProvider.getCollectionBehaviorInfo(publishSettings)\n    return {\n        defaultCollectionName = \"Only35 Photos\",\n        defaultCollectionCanBeDeleted = true,\n        canAddCollection = true,\n        maxCollectionSetDepth = 0, -- No collection sets, just collections\n    }\nend\n\n--------------------------------------------------------------------------------\n-- Metadata That Triggers Republish\n--------------------------------------------------------------------------------\n\nfunction publishServiceProvider.metadataThatTriggersRepublish(publishSettings)\n    return {\n        default = false,          -- Don't republish for most changes\n        title = true,             -- Republish when title changes\n        caption = true,           -- Republish when caption changes\n        keywords = true,          -- Republish when keywords change\n        gps = true,               -- Republish when GPS changes\n        dateCreated = true,       -- Republish when date changes\n        rating = true,            -- Republish when rating changes\n        pickStatus = true,        -- Republish when pick status changes\n    }\nend\n\n--------------------------------------------------------------------------------\n-- Metadata Extraction Helper\n--------------------------------------------------------------------------------\n\nlocal function extractMetadata(photo)\n    local metadata = {}\n    \n    -- Stars (rating 0-5)\n    metadata.stars = photo:getRawMetadata(\"rating\") or 0\n    \n    -- Selected (pick status)\n    local pickStatus = photo:getRawMetadata(\"pickStatus\")\n    metadata.selected = (pickStatus == \"flagged\")\n    \n    -- Keywords (as array of strings)\n    local keywords = photo:getRawMetadata(\"keywords\") or {}\n    local keywordStrings = {}\n    for _, keyword in ipairs(keywords) do\n        if type(keyword) == \"string\" then\n            table.insert(keywordStrings, keyword)\n        elseif keyword.getName then\n            table.insert(keywordStrings, keyword:getName())\n        end\n    end\n    metadata.keywords = keywordStrings\n    \n    -- Description (caption)\n    metadata.description = photo:getFormattedMetadata(\"caption\")\n    \n    -- Captured at (date)\n    local dateCreated = photo:getRawMetadata(\"dateTimeOriginal\")\n    if dateCreated then\n        metadata.capturedAt = dateCreated\n    end\n    \n    -- Location (GPS)\n    local gps = photo:getRawMetadata(\"gps\")\n    if gps and gps.latitude and gps.longitude then\n        metadata.location = {\n            latitude = gps.latitude,\n            longitude = gps.longitude,\n        }\n    end\n    \n    return metadata\nend\n\n--------------------------------------------------------------------------------\n-- Main Publish Function\n--------------------------------------------------------------------------------\n\nfunction publishServiceProvider.processRenderedPhotos(functionContext, exportContext)\n    local exportSession = exportContext.exportSession\n    local publishSettings = exportContext.propertyTable\n    \n    -- Check authentication\n    if not Only35Auth.isLoggedIn() then\n        LrDialogs.showError(\"Please log in to Only35 before publishing.\")\n        return\n    end\n    \n    -- Ensure we have a roll\n    local rollId = publishSettings.only35_roll_id\n    \n    if not rollId and publishSettings.only35_create_new_roll then\n        -- Create a new roll\n        local rollName = publishSettings.only35_roll_name\n        if not rollName or rollName == \"\" then\n            rollName = exportContext.publishedCollectionInfo.name or \"Lightroom Export\"\n        end\n        \n        Only35Utils.logInfo(\"Creating new roll: \" .. rollName)\n        \n        local roll = Only35API.createRoll(publishSettings, rollName)\n        if roll and roll.id then\n            rollId = roll.id\n            publishSettings.only35_roll_id = rollId\n        else\n            LrDialogs.showError(\"Failed to create roll. Please try again.\")\n            return\n        end\n    end\n    \n    if not rollId then\n        LrDialogs.showError(\"Please select a roll before publishing.\")\n        return\n    end\n    \n    -- Set up progress\n    local nPhotos = exportSession:countRenditions()\n    local progressScope = exportContext:configureProgress({\n        title = \"Publishing to Only35\",\n    })\n    \n    Only35Utils.logInfo(\"Starting publish of \" .. nPhotos .. \" photos\")\n    \n    -- Process each photo\n    local successCount = 0\n    local failureCount = 0\n    \n    for i, rendition in exportSession:renditions() do\n        progressScope:setPortionComplete(i - 1, nPhotos)\n        progressScope:setCaption(\"Publishing photo \" .. i .. \" of \" .. nPhotos)\n        \n        if progressScope:isCanceled() then\n            Only35Utils.logInfo(\"Publish cancelled by user\")\n            break\n        end\n        \n        -- Wait for rendering to complete\n        local success, pathOrMessage = rendition:waitForRender()\n        \n        if success then\n            local photo = rendition.photo\n            \n            -- Check if photo was previously published\n            local photoId = photo:getPropertyForPlugin(_PLUGIN, \"only35_photo_id\")\n            \n            local ok, err = pcall(function()\n                -- Get upload URL\n                local uploadInfo = Only35API.getUploadUrl(publishSettings, {\n                    rollId = rollId,\n                    filename = LrPathUtils.leafName(pathOrMessage),\n                    contentType = \"image/jpeg\",\n                })\n                \n                -- Upload to S3\n                Only35API.uploadToS3(uploadInfo.url, pathOrMessage, uploadInfo.headers)\n                \n                -- Extract metadata\n                local metadata = extractMetadata(photo)\n                \n                -- Create or update photograph record\n                if photoId then\n                    -- Update existing\n                    Only35API.updatePhotograph(publishSettings, photoId, metadata)\n                    Only35Utils.logInfo(\"Updated photo: \" .. photoId)\n                else\n                    -- Create new\n                    local newPhotoId = Only35API.createPhotograph(publishSettings, uploadInfo.photographId, metadata)\n                    \n                    -- Store the photo ID for future updates\n                    photo.catalog:withWriteAccessDo(\"Store Only35 ID\", function()\n                        photo:setPropertyForPlugin(_PLUGIN, \"only35_photo_id\", newPhotoId)\n                    end)\n                    \n                    Only35Utils.logInfo(\"Created photo: \" .. newPhotoId)\n                    photoId = newPhotoId\n                end\n                \n                -- Record as published\n                rendition:recordPublishedPhotoId(photoId)\n                successCount = successCount + 1\n            end)\n            \n            if not ok then\n                Only35Utils.logError(\"Failed to publish photo: \" .. tostring(err))\n                rendition:uploadFailed(tostring(err))\n                failureCount = failureCount + 1\n            end\n            \n            -- Clean up temporary file\n            LrFileUtils.delete(pathOrMessage)\n        else\n            Only35Utils.logError(\"Render failed: \" .. tostring(pathOrMessage))\n            rendition:uploadFailed(\"Rendering failed\")\n            failureCount = failureCount + 1\n        end\n    end\n    \n    progressScope:done()\n    \n    -- Show summary\n    if failureCount \u003e 0 then\n        LrDialogs.showError(\n            \"Published \" .. successCount .. \" photos to Only35.\\n\" ..\n            failureCount .. \" photos failed.\"\n        )\n    else\n        Only35Utils.logInfo(\"Published \" .. successCount .. \" photos successfully\")\n    end\nend\n\n--------------------------------------------------------------------------------\n-- Delete Photos\n--------------------------------------------------------------------------------\n\nfunction publishServiceProvider.deletePhotosFromPublishedCollection(publishSettings, arrayOfPhotoIds, deletedCallback, localCollectionId)\n    for i, photoId in ipairs(arrayOfPhotoIds) do\n        local ok, err = pcall(function()\n            Only35API.deletePhotograph(publishSettings, photoId)\n        end)\n        \n        if ok then\n            Only35Utils.logInfo(\"Deleted photo: \" .. photoId)\n        else\n            Only35Utils.logWarn(\"Failed to delete photo \" .. photoId .. \": \" .. tostring(err))\n        end\n        \n        -- Always mark as deleted locally\n        deletedCallback(photoId)\n    end\nend\n\n--------------------------------------------------------------------------------\n-- Collection Management\n--------------------------------------------------------------------------------\n\nfunction publishServiceProvider.renamePublishedCollection(publishSettings, info)\n    -- Roll renaming would require an API call - for now, just update locally\n    Only35Utils.logInfo(\"Collection renamed to: \" .. info.name)\nend\n\nfunction publishServiceProvider.deletePublishedCollection(publishSettings, info)\n    -- Could delete the roll on the server, but for safety just log\n    Only35Utils.logInfo(\"Collection deleted: \" .. info.name)\nend\n\n--------------------------------------------------------------------------------\n-- Return the provider\n--------------------------------------------------------------------------------\n\nreturn publishServiceProvider\n```\n\n## Exit Criteria\n\n```bash\n# File exists\ntest -f only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: Only35PublishServiceProvider.lua exists\" || echo \"FAIL: Only35PublishServiceProvider.lua missing\"\n\n# Check for core callbacks\ngrep -q \"function publishServiceProvider.processRenderedPhotos\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: processRenderedPhotos exists\" || echo \"FAIL: processRenderedPhotos missing\"\ngrep -q \"function publishServiceProvider.getCollectionBehaviorInfo\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: getCollectionBehaviorInfo exists\" || echo \"FAIL: getCollectionBehaviorInfo missing\"\ngrep -q \"function publishServiceProvider.metadataThatTriggersRepublish\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: metadataThatTriggersRepublish exists\" || echo \"FAIL: metadataThatTriggersRepublish missing\"\ngrep -q \"function publishServiceProvider.deletePhotosFromPublishedCollection\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: deletePhotosFromPublishedCollection exists\" || echo \"FAIL: deletePhotosFromPublishedCollection missing\"\n\n# Check for UI callbacks\ngrep -q \"function publishServiceProvider.sectionsForTopOfDialog\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: sectionsForTopOfDialog exists\" || echo \"FAIL: sectionsForTopOfDialog missing\"\ngrep -q \"function publishServiceProvider.viewForCollectionSettings\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: viewForCollectionSettings exists\" || echo \"FAIL: viewForCollectionSettings missing\"\ngrep -q \"function publishServiceProvider.startDialog\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: startDialog exists\" || echo \"FAIL: startDialog missing\"\n\n# Check for export settings\ngrep -q \"LR_format = \\\"JPEG\\\"\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: JPEG format set\" || echo \"FAIL: JPEG format missing\"\ngrep -q \"LR_jpeg_quality = 0.92\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: 92% quality set\" || echo \"FAIL: 92% quality missing\"\ngrep -q \"LR_size_maxWidth = 4096\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: Max width 4096 set\" || echo \"FAIL: Max width missing\"\ngrep -q \"LR_export_colorSpace = \\\"sRGB\\\"\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: sRGB color space set\" || echo \"FAIL: sRGB color space missing\"\n\n# Check for metadata mapping\ngrep -q \"metadata.stars = photo:getRawMetadata(\\\"rating\\\")\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: Rating mapped\" || echo \"FAIL: Rating mapping missing\"\ngrep -q \"pickStatus == \\\"flagged\\\"\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: Pick status mapped\" || echo \"FAIL: Pick status mapping missing\"\n\n# Check for integration\ngrep -q \"Only35API.getUploadUrl\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: Uses API for upload URL\" || echo \"FAIL: API upload URL not used\"\ngrep -q \"Only35API.uploadToS3\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: Uses S3 upload\" || echo \"FAIL: S3 upload not used\"\ngrep -q \"Only35Auth.isLoggedIn\" only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: Uses auth check\" || echo \"FAIL: Auth check not used\"\n\n# Lua syntax check\nlua -e \"local ok, err = loadfile('only35.lrplugin/Only35PublishServiceProvider.lua'); if not ok then print('FAIL: ' .. err); os.exit(1) else print('PASS: Lua syntax valid') end\" 2\u003e/dev/null || echo \"PASS: Lua syntax valid (lua not installed)\"\n```\n\n### Verification Checklist\n- [ ] Only35PublishServiceProvider.lua created\n- [ ] processRenderedPhotos() with full upload loop\n- [ ] getCollectionBehaviorInfo() returns defaults\n- [ ] metadataThatTriggersRepublish() lists all trigger fields\n- [ ] deletePhotosFromPublishedCollection() handles deletion\n- [ ] sectionsForTopOfDialog() with login UI\n- [ ] viewForCollectionSettings() with roll dropdown\n- [ ] startDialog() initializes state\n- [ ] Metadata mapping: rating-\u003estars, pickStatus-\u003eselected, keywords, caption, dateCreated, gps\n- [ ] Export settings: JPEG 92%, 4096x4096, sRGB, sharpening level 2\n- [ ] Uses Only35API for all HTTP calls\n- [ ] Uses Only35Auth for login state\n- [ ] Error handling with user dialogs\n- [ ] Progress reporting during upload\n- [ ] Lua syntax is valid\n\n## Files to Modify\n\n- `only35.lrplugin/Only35PublishServiceProvider.lua` (CREATE) - Complete publish service provider","status":"closed","priority":2,"issue_type":"task","owner":"carlo.nicora@gmail.com","created_at":"2026-01-20T08:57:44.563918+01:00","created_by":"Carlo Nicora","updated_at":"2026-01-20T09:08:33.492947+01:00","closed_at":"2026-01-20T09:08:33.492947+01:00","close_reason":"Done: Created complete Publish Service Provider with UI, metadata mapping, export settings, and photo upload","labels":["openspec:lightroom-plugin"],"dependencies":[{"issue_id":"only35.lightroom-utt.5","depends_on_id":"only35.lightroom-utt","type":"parent-child","created_at":"2026-01-20T08:57:44.564766+01:00","created_by":"Carlo Nicora"},{"issue_id":"only35.lightroom-utt.5","depends_on_id":"only35.lightroom-utt.4","type":"blocks","created_at":"2026-01-20T08:59:16.227037+01:00","created_by":"Carlo Nicora"}]}
{"id":"only35.lightroom-utt.6","title":"Add Error Handling and Retry Logic","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/lightroom-plugin/\n**Task**: 5.1 Error Handling from tasks.md\n**Depends On**: Task 4.1 (Error handling across modules)\n\n## Requirements\n\nEnhance all modules with robust error handling patterns.\n\n**Error Handling Requirements:**\n- Network error retry with exponential backoff (max 3 retries)\n- API error parsing with user-friendly messages\n- S3 upload failure handling with retry\n- Rate limiting (429) respects Retry-After header\n- Token expiration triggers auto-refresh\n- User-facing dialogs for unrecoverable errors\n\n**Error Categories:**\n1. Network errors (no response) - Retry with backoff\n2. Auth errors (401) - Refresh token, retry once\n3. Rate limits (429) - Wait for Retry-After, retry\n4. Server errors (5xx) - Retry with backoff\n5. Client errors (4xx) - Show error, don't retry\n6. S3 errors - Retry upload, then fail\n\n**User Messages:**\n- \"Could not connect to Only35. Please check your internet connection.\"\n- \"Authentication expired. Please log in again.\"\n- \"Upload failed. Please try again.\"\n- \"Only35 is temporarily unavailable. Please try again in a few minutes.\"\n\n## Reference Implementation\n\nThis task enhances existing modules. The primary changes are already included in Only35API.lua from Task 3.1. This task verifies and documents the error handling patterns.\n\nVERIFY FILE: `only35.lrplugin/Only35API.lua`\n\nEnsure these patterns exist:\n\n```lua\n--------------------------------------------------------------------------------\n-- Error Handling Patterns (verify these exist)\n--------------------------------------------------------------------------------\n\n-- Pattern 1: Exponential Backoff Retry\nlocal function withRetry(fn, maxRetries)\n    maxRetries = maxRetries or 3\n    local retryCount = 0\n    \n    while retryCount \u003c maxRetries do\n        local ok, result = pcall(fn)\n        if ok then\n            return result\n        end\n        \n        retryCount = retryCount + 1\n        if retryCount \u003c maxRetries then\n            local delay = 2 ^ (retryCount - 1) -- 1s, 2s, 4s\n            Only35Utils.logWarn(\"Retrying in \" .. delay .. \" seconds...\")\n            LrTasks.sleep(delay)\n        else\n            error(result)\n        end\n    end\nend\n\n-- Pattern 2: Rate Limit Handling\n-- In postJson/get functions, check for 429:\nif status == 429 then\n    local retryAfter = 60\n    for _, header in ipairs(responseHeaders) do\n        if header.field:lower() == \"retry-after\" then\n            retryAfter = tonumber(header.value) or 60\n            break\n        end\n    end\n    Only35Utils.logWarn(\"Rate limited, waiting \" .. retryAfter .. \" seconds\")\n    LrTasks.sleep(retryAfter)\n    return self:postJson(url, data, retryCount) -- Retry\nend\n\n-- Pattern 3: Token Auto-Refresh on 401\nif status == 401 then\n    Only35Utils.logWarn(\"Got 401, attempting token refresh\")\n    if Only35Auth.refreshAccessToken() then\n        return self:postJson(url, data, 0) -- Retry with new token\n    end\n    error(\"Authentication expired. Please log in again.\")\nend\n\n-- Pattern 4: User-Friendly Error Messages\nlocal ERROR_MESSAGES = {\n    network = \"Could not connect to Only35. Please check your internet connection.\",\n    auth = \"Authentication expired. Please log in again.\",\n    upload = \"Upload failed. Please try again.\",\n    server = \"Only35 is temporarily unavailable. Please try again in a few minutes.\",\n    rate_limit = \"Too many requests. Please wait a moment and try again.\",\n}\n\n-- Pattern 5: S3 Upload Retry\nfunction Only35API.uploadToS3(presignedUrl, filePath, headers, retryCount)\n    retryCount = retryCount or 0\n    local maxRetries = 3\n    \n    -- ... upload logic ...\n    \n    if status ~= 200 and status ~= 204 then\n        if retryCount \u003c maxRetries then\n            Only35Utils.logWarn(\"S3 upload failed, retrying...\")\n            LrTasks.sleep(2 ^ retryCount)\n            return Only35API.uploadToS3(presignedUrl, filePath, headers, retryCount + 1)\n        end\n        error(\"Failed to upload photo after \" .. maxRetries .. \" attempts\")\n    end\nend\n```\n\nCREATE/UPDATE: Error handling utilities in Only35Utils.lua\n\n```lua\n--------------------------------------------------------------------------------\n-- Error Handling Utilities (add to Only35Utils.lua)\n--------------------------------------------------------------------------------\n\nOnly35Utils.ERROR_MESSAGES = {\n    network = \"Could not connect to Only35. Please check your internet connection.\",\n    auth = \"Authentication expired. Please log in again.\",\n    upload = \"Upload failed. Please try again.\",\n    server = \"Only35 is temporarily unavailable. Please try again in a few minutes.\",\n    rate_limit = \"Too many requests. Please wait a moment and try again.\",\n    unknown = \"An unexpected error occurred. Please try again.\",\n}\n\n--- Show a user-friendly error dialog\n-- @param errorType Key from ERROR_MESSAGES or custom message\n-- @param details Optional technical details for logging\nfunction Only35Utils.showError(errorType, details)\n    local message = Only35Utils.ERROR_MESSAGES[errorType] or errorType\n    \n    if details then\n        Only35Utils.logError(message .. \" Details: \" .. tostring(details))\n    else\n        Only35Utils.logError(message)\n    end\n    \n    LrDialogs.showError(message)\nend\n\n--- Wrap a function with retry logic\n-- @param fn Function to execute\n-- @param options Table with maxRetries, baseDelay, shouldRetry\n-- @return Result of fn or error\nfunction Only35Utils.withRetry(fn, options)\n    options = options or {}\n    local maxRetries = options.maxRetries or 3\n    local baseDelay = options.baseDelay or 1\n    local shouldRetry = options.shouldRetry or function(err) return true end\n    \n    local lastError\n    for attempt = 1, maxRetries do\n        local ok, result = pcall(fn)\n        \n        if ok then\n            return result\n        end\n        \n        lastError = result\n        \n        if attempt \u003c maxRetries and shouldRetry(result) then\n            local delay = baseDelay * (2 ^ (attempt - 1))\n            Only35Utils.logWarn(\n                \"Attempt \" .. attempt .. \" failed, retrying in \" .. delay .. \"s: \" .. \n                tostring(result)\n            )\n            LrTasks.sleep(delay)\n        end\n    end\n    \n    error(lastError)\nend\n```\n\n## Exit Criteria\n\n```bash\n# Verify retry logic exists in API\ngrep -q \"retryCount\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Retry logic exists\" || echo \"FAIL: Retry logic missing\"\ngrep -q \"status == 429\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Rate limit handling exists\" || echo \"FAIL: Rate limit handling missing\"\ngrep -q \"status == 401\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Auth error handling exists\" || echo \"FAIL: Auth error handling missing\"\ngrep -q \"status \u003e= 500\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Server error handling exists\" || echo \"FAIL: Server error handling missing\"\n\n# Verify exponential backoff pattern\ngrep -q \"2 \\^ retryCount\\|2 \\^.*retry\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: Exponential backoff exists\" || echo \"FAIL: Exponential backoff missing\"\n\n# Verify user-friendly messages\ngrep -q \"Please check your internet\\|Please log in\\|Please try again\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: User-friendly messages exist\" || echo \"FAIL: User-friendly messages missing\"\n\n# Verify S3 retry logic\ngrep -q \"S3 upload\\|uploadToS3\" only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: S3 upload function exists\" || echo \"FAIL: S3 upload missing\"\n\n# Lua syntax check\nlua -e \"local ok, err = loadfile('only35.lrplugin/Only35API.lua'); if not ok then print('FAIL: ' .. err); os.exit(1) else print('PASS: Lua syntax valid') end\" 2\u003e/dev/null || echo \"PASS: Lua syntax valid (lua not installed)\"\n```\n\n### Verification Checklist\n- [ ] Retry logic with exponential backoff (1s, 2s, 4s)\n- [ ] Max 3 retries for network/server errors\n- [ ] 401 triggers token refresh then retry\n- [ ] 429 respects Retry-After header\n- [ ] 5xx errors retry with backoff\n- [ ] 4xx errors shown to user, no retry\n- [ ] S3 upload has retry logic\n- [ ] User-friendly error messages for all cases\n- [ ] All errors logged for debugging\n- [ ] Lua syntax is valid\n\n## Files to Modify\n\n- `only35.lrplugin/Only35API.lua` (VERIFY/UPDATE) - Ensure error handling patterns\n- `only35.lrplugin/Only35Utils.lua` (UPDATE) - Add error utility functions","status":"closed","priority":2,"issue_type":"task","owner":"carlo.nicora@gmail.com","created_at":"2026-01-20T08:58:28.315019+01:00","created_by":"Carlo Nicora","updated_at":"2026-01-20T09:09:16.397012+01:00","closed_at":"2026-01-20T09:09:16.397012+01:00","close_reason":"Done: Error handling already implemented in Only35API.lua - retry logic, rate limiting, auth refresh, exponential backoff all in place","labels":["openspec:lightroom-plugin"],"dependencies":[{"issue_id":"only35.lightroom-utt.6","depends_on_id":"only35.lightroom-utt","type":"parent-child","created_at":"2026-01-20T08:58:28.315829+01:00","created_by":"Carlo Nicora"},{"issue_id":"only35.lightroom-utt.6","depends_on_id":"only35.lightroom-utt.5","type":"blocks","created_at":"2026-01-20T08:59:16.283478+01:00","created_by":"Carlo Nicora"}]}
{"id":"only35.lightroom-utt.7","title":"Create Distribution Package","description":"## Context Chain (disaster recovery only)\n\n**Spec Reference**: openspec/changes/lightroom-plugin/\n**Task**: 5.2 Distribution from tasks.md\n**Depends On**: Task 5.1 (Distribution after complete)\n\n## Requirements\n\nFinalize the plugin package structure and prepare for distribution.\n\n**Package Structure:**\n```\nonly35.lrplugin/\n├── Info.lua                          # Plugin manifest\n├── Only35PublishServiceProvider.lua  # Publish service\n├── Only35API.lua                     # HTTP client\n├── Only35Auth.lua                    # OAuth\n├── Only35Utils.lua                   # Utilities\n├── Only35InfoProvider.lua            # Plugin info\n├── json.lua                          # JSON library\n└── only35_icon.png                   # Plugin icon (optional)\n```\n\n**Installation Testing:**\n1. Open Lightroom Classic\n2. File \u003e Plug-in Manager\n3. Click \"Add\" button\n4. Navigate to only35.lrplugin folder\n5. Verify plugin appears in list\n6. Test publish service appears in Library module\n\n**Documentation:**\n- README in plugin folder (minimal, for developer reference)\n- Installation steps clear and tested\n\n## Reference Implementation\n\nVERIFY STRUCTURE:\n\n```bash\n# Required files\nonly35.lrplugin/\n├── Info.lua                          # REQUIRED - Plugin manifest\n├── Only35PublishServiceProvider.lua  # REQUIRED - Main service\n├── Only35API.lua                     # REQUIRED - API client\n├── Only35Auth.lua                    # REQUIRED - Auth module\n├── Only35Utils.lua                   # REQUIRED - Utilities\n├── Only35InfoProvider.lua            # REQUIRED - Plugin info\n└── json.lua                          # REQUIRED - JSON library\n```\n\nCREATE FILE: `only35.lrplugin/README.txt`\n\n```text\nOnly35 Lightroom Plugin\n=======================\n\nInstallation\n------------\n1. Open Lightroom Classic\n2. Go to File \u003e Plug-in Manager\n3. Click the \"Add\" button at bottom left\n4. Navigate to and select this folder (only35.lrplugin)\n5. Click \"Add Plug-in\"\n\nThe plugin should now appear in your Plug-in Manager list.\n\nUsage\n-----\n1. In the Library module, click \"Publish Services\" in the left panel\n2. Click \"Set Up...\" next to \"Only35\"\n3. Click \"Login\" to authenticate with your Only35 account\n4. Create a Published Collection to start uploading photos\n\nTroubleshooting\n---------------\nIf you encounter issues:\n- Check that you are logged in (Publish Services \u003e Only35 \u003e Edit Settings)\n- Verify your internet connection\n- Check Lightroom logs in ~/Documents/Adobe/Lightroom/Logs/\n\nFor support, visit: https://only35.com/help/lightroom\n\nVersion\n-------\n1.0.0\n\nLicense\n-------\nCopyright (c) Only35. All rights reserved.\n```\n\nOPTIONAL: Create a simple icon\n\n```lua\n-- If you have a PNG icon, place it at:\n-- only35.lrplugin/only35_icon.png\n-- \n-- Dimensions: 16x16 or 20x20 pixels\n-- Format: PNG with transparency\n-- \n-- If no icon is provided, Lightroom will use a default icon.\n```\n\nVERIFY MANIFEST references all files:\n\n```lua\n-- In Info.lua, verify these are present:\nreturn {\n    LrSdkVersion = 13.0,\n    LrSdkMinimumVersion = 10.0,\n    LrToolkitIdentifier = \"com.only35.lightroom\",\n    LrPluginName = \"Only35\",\n    \n    LrExportServiceProvider = {\n        title = \"Only35\",\n        file = \"Only35PublishServiceProvider.lua\",\n    },\n    \n    LrPluginInfoProvider = \"Only35InfoProvider.lua\",\n    \n    VERSION = { major = 1, minor = 0, revision = 0, build = 1 },\n}\n```\n\n## Exit Criteria\n\n```bash\n# All required files exist\ntest -d only35.lrplugin \u0026\u0026 echo \"PASS: Plugin directory exists\" || echo \"FAIL: Plugin directory missing\"\ntest -f only35.lrplugin/Info.lua \u0026\u0026 echo \"PASS: Info.lua exists\" || echo \"FAIL: Info.lua missing\"\ntest -f only35.lrplugin/Only35PublishServiceProvider.lua \u0026\u0026 echo \"PASS: ServiceProvider exists\" || echo \"FAIL: ServiceProvider missing\"\ntest -f only35.lrplugin/Only35API.lua \u0026\u0026 echo \"PASS: API exists\" || echo \"FAIL: API missing\"\ntest -f only35.lrplugin/Only35Auth.lua \u0026\u0026 echo \"PASS: Auth exists\" || echo \"FAIL: Auth missing\"\ntest -f only35.lrplugin/Only35Utils.lua \u0026\u0026 echo \"PASS: Utils exists\" || echo \"FAIL: Utils missing\"\ntest -f only35.lrplugin/Only35InfoProvider.lua \u0026\u0026 echo \"PASS: InfoProvider exists\" || echo \"FAIL: InfoProvider missing\"\ntest -f only35.lrplugin/json.lua \u0026\u0026 echo \"PASS: json.lua exists\" || echo \"FAIL: json.lua missing\"\ntest -f only35.lrplugin/README.txt \u0026\u0026 echo \"PASS: README exists\" || echo \"FAIL: README missing\"\n\n# File count check\nFILE_COUNT=$(ls -1 only35.lrplugin/*.lua 2\u003e/dev/null | wc -l | tr -d ' ')\ntest \"$FILE_COUNT\" -ge 6 \u0026\u0026 echo \"PASS: All Lua files present ($FILE_COUNT)\" || echo \"FAIL: Missing Lua files ($FILE_COUNT found)\"\n\n# Lua syntax check on all files\nfor f in only35.lrplugin/*.lua; do\n    lua -e \"local ok, err = loadfile('$f'); if not ok then print('FAIL: ' .. err); os.exit(1) end\" 2\u003e/dev/null || true\ndone\necho \"Lua syntax check complete\"\n\n# Manifest references check\ngrep -q \"Only35PublishServiceProvider.lua\" only35.lrplugin/Info.lua \u0026\u0026 echo \"PASS: Manifest references ServiceProvider\" || echo \"FAIL: Manifest missing ServiceProvider reference\"\ngrep -q \"Only35InfoProvider.lua\" only35.lrplugin/Info.lua \u0026\u0026 echo \"PASS: Manifest references InfoProvider\" || echo \"FAIL: Manifest missing InfoProvider reference\"\n\n# List final structure\necho \"\"\necho \"Final plugin structure:\"\nls -la only35.lrplugin/\n```\n\n### Verification Checklist\n- [ ] only35.lrplugin/ directory with .lrplugin suffix\n- [ ] Info.lua - plugin manifest present\n- [ ] Only35PublishServiceProvider.lua present\n- [ ] Only35API.lua present\n- [ ] Only35Auth.lua present\n- [ ] Only35Utils.lua present\n- [ ] Only35InfoProvider.lua present\n- [ ] json.lua present\n- [ ] README.txt with installation instructions\n- [ ] All Lua files have valid syntax\n- [ ] Info.lua references all required files\n- [ ] Minimum 6 Lua files in plugin\n\n## Files to Modify\n\n- `only35.lrplugin/README.txt` (CREATE) - Installation and usage documentation\n- `only35.lrplugin/` (VERIFY) - All required files present","status":"closed","priority":3,"issue_type":"task","owner":"carlo.nicora@gmail.com","created_at":"2026-01-20T08:59:06.493276+01:00","created_by":"Carlo Nicora","updated_at":"2026-01-20T09:09:49.425349+01:00","closed_at":"2026-01-20T09:09:49.425349+01:00","close_reason":"Done: Plugin package complete with 7 Lua files, README.txt, and all required structure verified","labels":["openspec:lightroom-plugin"],"dependencies":[{"issue_id":"only35.lightroom-utt.7","depends_on_id":"only35.lightroom-utt","type":"parent-child","created_at":"2026-01-20T08:59:06.494065+01:00","created_by":"Carlo Nicora"},{"issue_id":"only35.lightroom-utt.7","depends_on_id":"only35.lightroom-utt.6","type":"blocks","created_at":"2026-01-20T08:59:16.340524+01:00","created_by":"Carlo Nicora"}]}
